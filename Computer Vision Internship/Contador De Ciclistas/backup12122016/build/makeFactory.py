#!/usr/bin/python
#Create EOC factory class based on modules present on modules folder

import os
import re

modulesDir = "../modules"
relativeModulesDir = "../../modules"
headersOutDir = "../include/modules"
includeDir = "../include"
sourceDir = "../src"
dbPath = "../EOC.db"

class Module(object):
    """Module abstraction. Used to simplify .hpp and .cpp files 
    generation"""
    def __init__(self):
        self.name = None
        self.code = None
        self.id = None
        self.db = None;
        self.header = None
        self.classes = []
        
    def GetPreprocessor(self):
        """Infer preprocessor class"""
        retVal = None
        for element in self.classes:
            if re.search("preprocessor", element, re.I) is not None:
                retVal = element
                break
        return retVal
    
    def GetDetector(self):
        """Infer detector class"""
        retVal = None
        for element in self.classes:
            if re.search("detector", element, re.I) is not None:
                retVal = element
                break
        return retVal
        
    def GetClassifier(self):
        """Infer classifier class"""
        retVal = None
        for element in self.classes:
            if re.search("classifier", element, re.I) is not None:
                retVal = element
                break
        return retVal

    def __str__(self):
        ret = ""
        ret += self.name + "\n"
        ret += self.code + "\n"
        ret += self.header + "\n"
        ret += str(self.classes)
        return ret

def ProcessModules(modulesDir):
    """Retrieve modules present on modulesDir folder and create unified 
    include file on indclude dir"""
    moduleObjects = []
    modules = os.listdir(modulesDir)
    for module in modules:
            modulePath = os.path.join(modulesDir, module)
            
            idPath = os.path.join(modulePath, "module.id")
            moduleId = -1
            with open(idPath) as fd:
                moduleId = int(fd.readline())
                
            dbPath = os.path.join(modulePath, "module.schema")
            moduleSchema = None
            with open(dbPath) as fd:
                moduleSchema = fd.readline()
                
            headers = GetModuleHeaders(modulePath)
            moduleHeaderName = CreateHeader(module, modulePath, headers)
            
            obj = Module()
            obj.id = moduleId
            obj.db = moduleSchema
            obj.name = module
            obj.code = re.sub("([a-z])([A-Z])", "\\1_\\2", module).upper()
            obj.header = moduleHeaderName
            for header in headers:
                obj.classes.append(re.sub("\.hpp", "", header))
            
            moduleObjects.append(obj)
    return moduleObjects

def GetModuleHeaders(modulePath):
    """Get all .hpp files names"""
    headers = []
    files = os.listdir(modulePath)
    for file in files:
        if re.search("\.hpp$", file, re.I) is not None:
            headers.append(file)
    return headers

def CreateHeader(module, modulePath, moduleFiles):
    """Create unified .hpp file"""
    moduleHeaderName = module + ".hpp"
    headerOut = os.path.join(headersOutDir, moduleHeaderName)
    fd = open(headerOut, "w")
    for file in moduleFiles:
        fullHeaderPath = os.path.join(relativeModulesDir, module, file)
        fd.write('#include "' + fullHeaderPath + '"\n')
    fd.close()
    return moduleHeaderName

def MakeHpp(modules):
    """Create Factory.hpp file according to modules found within modules
     folder"""
    factoryHpp = """\
/* THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY */

#ifndef FACTORY_HPP
#define FACTORY_HPP

#include "Preprocessor.hpp"
#include "Detector.hpp"
#include "Classifier.hpp"
#include "Config.hpp"

enum ProcessorType {\n"""
    for module in modules:
        factoryHpp += "\t" + module.code + " = " + str(module.id) + ",\n"

    factoryHpp += """\
};

/**
 * @brief This class is autogenerated by build/makeFactory.py utility.
 * it is a module factory for each component on modules folder
 */ 
class Factory {
    private:
            Conf *configuration;
            int processorId;
            ProcessorType processorType;
    public:
            Factory(int , Conf &cfg);

            /**
             * @brief Converts string name to enum element
             */
            static ProcessorType getProcessorType(std::string);            
            
            /**
             * @brief Creates new processor instance according to
             * ProcessorType set on class constructor
             */
            Preprocessor *createPreprocessor();
            
            /**
             * @brief Creates new classifier instance according to
             * ProcessorType set on class constructor
             */
            Classifier *createClassifier();
            
            /**
             * @brief Creates new detector instance according to
             * ProcessorType set on class constructor
             */
            Detector *createDetector();
};

#endif
    """
    fd = open(os.path.join(includeDir, "Factory.hpp"), "w")
    fd.write(factoryHpp)
    fd.close();
    return factoryHpp;

def MakeCpp(modules):
        """Create Factory.cpp file according to modules found within modules
        folder"""
        factoryCpp = """\
/* THIS FILE IS AUTOMATICALLY GENERATED. DO NOT MODIFY */

#include "Factory.hpp"

/* Modules */\n"""
        for module in modules:
            factoryCpp += '#include "modules/' + module.header + '"\n'

        factoryCpp += """\nFactory::Factory(int processorId, Conf &cfg) {
        this->processorId = processorId;
        this->configuration = &cfg;
        
        std::string sProcessorType = this->configuration->processorProcessorType(this->processorId);
        this->processorType = this->getProcessorType(sProcessorType);
}

ProcessorType Factory::getProcessorType(std::string module) {
"""
        for module in modules:
            factoryCpp += '\tif (module == "' + module.name + '") {\n\t\t return ' + module.code + ';\n\t}\n'

        factoryCpp += """}

Preprocessor *Factory::createPreprocessor() {
        Preprocessor *preprocessor;
        switch(this->processorType) {\n"""
        for module in modules:
            if (module.GetPreprocessor() is not None):
                factoryCpp += "\t" * 3 + "case " + module.code + ":\n"    
                factoryCpp += "\t" * 4 + "preprocessor = dynamic_cast<Preprocessor *>(new " + module.GetPreprocessor() + "(this->processorId, *this->configuration));\n"
                factoryCpp += "\t" * 4 + "break;\n"

        factoryCpp +="""\t\t}
        return preprocessor;
}

Detector *Factory::createDetector() {
        Detector *detector;
        switch(this->processorType) {\n"""
        for module in modules:
            if (module.GetDetector() is not None):
                factoryCpp += "\t" * 3 + "case " + module.code + ":\n"    
                factoryCpp += "\t" * 4 + "detector = dynamic_cast<Detector *>(new " + module.GetDetector() + "(this->processorId, *this->configuration));\n"
                factoryCpp += "\t" * 4 + "break;\n"

        factoryCpp +="""\t\t}
        return detector;
}

Classifier *Factory::createClassifier() {
        Classifier *classifier;
        switch(this->processorType) {\n"""
        for module in modules:
            if (module.GetClassifier() is not None):
                factoryCpp += "\t" * 3 + "case " + module.code + ":\n"    
                factoryCpp += "\t" * 4 + "classifier = dynamic_cast<Classifier *>(new " + module.GetClassifier() + "(this->processorId, *this->configuration));\n"
                factoryCpp += "\t" * 4 + "break;\n"

        factoryCpp += """\t\t}
        return classifier;
}
        """
        fd = open(os.path.join(sourceDir, "Factory.cpp"), "w")
        fd.write(factoryCpp)
        fd.close();
        return factoryCpp

def BuildDb(modules):
    for module in modules:
        line = 'echo "' + module.db + '" | sqlite3 ' + dbPath 
        os.system(line)

if __name__ == "__main__":
    if os.path.exists(dbPath):
        os.remove(dbPath)
    
    modules = ProcessModules(modulesDir)
    MakeCpp(modules)
    MakeHpp(modules)
    BuildDb(modules)
